class Plant

instance variables 
  schedule : map Period to set of Expert;
  alarms   : set of Alarm;
  inv  forall exs in set rng schedule &
       exs <> {} and
         forall ex1, ex2 in set exs &
          ex1 <> ex2 => ex1.expertid <> ex2.expertid ; 
    

  ok : bool;
     
      
types
 public Period = token;

  public Expert :: expertid : ExpertId
            quali    : set of Qualification
  inv ex == ex.quali <> {};

  public ExpertId = token;

  public Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     
  public Alarm :: alarmtext : seq of char
           quali     : Qualification


operations
public Plant : () ==> Plant
Plant () == (
  schedule := {|->};
  alarms := {};
  ok := true;
);

checkDanger : () ==> ()
checkDanger ()== (
  let 
    allQualisOk  = forall a in set alarms &
                    forall peri in set dom schedule &
                      QualificationOK(schedule(peri),a.quali)
  in 
    ok := allQualisOk;                  
);

public bar : () ==> ()
bar() == ok := not ok;

public AssignExpert : Expert * Period ==> ()
AssignExpert(e,p) == (
  if p in set dom schedule then
    schedule(p) := schedule(p) union {e}
  else
    schedule := schedule munion {p|->{e}};
  checkDanger();
)
pre rng schedule <> {} => e not in set dinter rng schedule;

public AddAlarm : Alarm ==> ()
AddAlarm (a) == (
  alarms := alarms union {a};
  checkDanger();
);

public ExpertToPage : Period ==> Expert
ExpertToPage (p) == 
  let 
    e in set dinter rng schedule 
  be st
    e in set schedule(p)
  in
    return e
pre p in set dom schedule; 

public NumberOfExperts: Period  ==> nat
NumberOfExperts(peri) == return card schedule(peri)
pre peri in set dom schedule;

public ExpertIsOnDuty: Expert ==> set of Period
ExpertIsOnDuty(ex) ==
  return {peri| peri in set dom schedule & ex in set schedule(peri)};

functions
QualificationOK: set of Expert * Qualification -> bool
QualificationOK(exs,reqquali) ==
  exists ex in set exs & reqquali in set ex.quali;

end Plant